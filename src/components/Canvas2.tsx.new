import React, { forwardRef, useEffect, useRef, Dispatch, SetStateAction, useCallback } from 'react';
import { DrawingCommand, Point, Page } from './types/drawing';

type DrawingTool = 'select' | 'pencil' | 'eraser' | 'line' | 'rectangle' | 'circle' | 'text';
type BrushStyle = 'pencil' | 'pen' | 'marker' | 'paint';

interface SelectionArea {
    x: number;
    y: number;
    width: number;
    height: number;
}

interface CanvasProps {
    currentPage: Page;
    setCurrentPage: Dispatch<SetStateAction<Page>>;
    currentAction: DrawingCommand | null;
    setCurrentAction: Dispatch<SetStateAction<DrawingCommand | null>>;
    isDrawing: boolean;
    setIsDrawing: Dispatch<SetStateAction<boolean>>;
    currentTool: DrawingTool;
    currentColor: string;
    currentBrushSize: number;
    currentBrushType: BrushStyle;
    setShowTextInput: Dispatch<SetStateAction<boolean>>;
    setTextPosition: Dispatch<SetStateAction<Point | null>>;
    zoomLevel: number;
    selectedElements: DrawingCommand[];
    setSelectedElements: Dispatch<SetStateAction<DrawingCommand[]>>;
    selectionArea: SelectionArea | null;
    setSelectionArea: Dispatch<SetStateAction<SelectionArea | null>>;
    isDragging: boolean;
    setIsDragging: Dispatch<SetStateAction<boolean>>;
    dragStart: Point | null;
    setDragStart: Dispatch<SetStateAction<Point | null>>;
    handleStartSelect: (point: Point) => void;
    handleUpdateSelection: (point: Point) => void;
    handleFinishSelect: () => void;
    updateSelectedElements: (offsetX: number, offsetY: number) => void;
}

export const Canvas2 = forwardRef<HTMLCanvasElement, CanvasProps>((props, ref) => {
    const {
        currentPage,
        setCurrentPage,
        currentAction,
        setCurrentAction,
        isDrawing,
        setIsDrawing,
        currentTool,
        currentColor,
        currentBrushSize,
        currentBrushType,
        setShowTextInput,
        setTextPosition,
        zoomLevel,
        selectedElements,
        setSelectedElements,
        selectionArea,
        setSelectionArea,
        isDragging,
        setIsDragging,
        dragStart,
        setDragStart,
        handleStartSelect,
        handleUpdateSelection,
        handleFinishSelect,
        updateSelectedElements,
    } = props;

    const canvasRef = useRef<HTMLCanvasElement>(null);
    const tempCanvasRef = useRef<HTMLCanvasElement>(null);
    const zoomFactor = zoomLevel / 100;

    useEffect(() => {
        if (ref && typeof ref === 'object' && 'current' in ref) {
            (ref as React.MutableRefObject<HTMLCanvasElement | null>).current = canvasRef.current;
        }
    }, [ref]);

    const getMousePosition = (e: React.MouseEvent<HTMLCanvasElement>): Point => {
        const rect = e.currentTarget.getBoundingClientRect();
        return {
            x: (e.clientX - rect.left) / zoomFactor,
            y: (e.clientY - rect.top) / zoomFactor
        };
    };

    useEffect(() => {
        if (!canvasRef.current || !tempCanvasRef.current) return;

        const canvas = canvasRef.current;
        const tempCanvas = tempCanvasRef.current;
        const context = canvas.getContext('2d');
        const tempContext = tempCanvas.getContext('2d');

        if (!context || !tempContext) return;

        // Xóa cả hai canvas
        context.clearRect(0, 0, canvas.width, canvas.height);
        tempContext.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
        
        // Lưu trạng thái và áp dụng zoom cho canvas chính
        context.save();
        context.scale(zoomFactor, zoomFactor);
        
        // Lưu trạng thái và áp dụng zoom cho canvas tạm
        tempContext.save();
        tempContext.scale(zoomFactor, zoomFactor);

        // Vẽ các lệnh trên canvas
        currentPage.commands.forEach((command) => {
            if (command.type === 'image' && command.image) {
                context.drawImage(command.image, 0, 0, canvas.width / zoomFactor, canvas.height / zoomFactor);
            } else {
                tempContext.beginPath();
                tempContext.lineCap = 'round';
                tempContext.lineJoin = 'round';
                tempContext.strokeStyle = command.color;
                tempContext.lineWidth = command.size / zoomFactor;

                // Vẽ outline cho phần tử được chọn
                if (selectedElements.includes(command)) {
                    tempContext.shadowColor = '#3B82F6';
                    tempContext.shadowBlur = 5;
                } else {
                    tempContext.shadowColor = 'transparent';
                    tempContext.shadowBlur = 0;
                }

                // Áp dụng hiệu ứng theo loại bút
                if (command.brushType === 'paint') {
                    tempContext.globalAlpha = 0.5;
                    tempContext.lineWidth = (command.size * 2) / zoomFactor;
                } else if (command.brushType === 'marker') {
                    tempContext.globalAlpha = 0.7;
                } else if (command.brushType === 'pen') {
                    tempContext.lineWidth = (command.size * 0.5) / zoomFactor;
                    tempContext.globalAlpha = 1;
                }

                if (command.type === 'freehand' || command.type === 'erase') {
                    if (command.points && command.points.length > 0) {
                        tempContext.moveTo(command.points[0].x, command.points[0].y);
                        command.points.forEach((point) => tempContext.lineTo(point.x, point.y));
                        tempContext.strokeStyle = command.type === 'erase' ? '#FFFFFF' : command.color;
                        tempContext.globalCompositeOperation = command.type === 'erase' ? 'destination-out' : 'source-over';
                        tempContext.stroke();
                    }
                } else if (command.type === 'line') {
                    if (command.fromX !== undefined && command.fromY !== undefined && 
                        command.toX !== undefined && command.toY !== undefined) {
                        tempContext.moveTo(command.fromX, command.fromY);
                        tempContext.lineTo(command.toX, command.toY);
                        tempContext.stroke();
                    }
                } else if (command.type === 'rectangle') {
                    if (command.x !== undefined && command.y !== undefined && 
                        command.width !== undefined && command.height !== undefined) {
                        tempContext.strokeRect(command.x, command.y, command.width, command.height);
                    }
                } else if (command.type === 'circle') {
                    if (command.x !== undefined && command.y !== undefined && 
                        command.radius !== undefined) {
                        tempContext.beginPath();
                        tempContext.arc(command.x, command.y, command.radius, 0, 2 * Math.PI);
                        tempContext.stroke();
                    }
                } else if (command.type === 'text') {
                    if (command.x !== undefined && command.y !== undefined && command.text) {
                        tempContext.font = command.font || `${16 / zoomFactor}px Arial`;
                        tempContext.fillStyle = command.color;
                        tempContext.fillText(command.text, command.x, command.y);
                    }
                }

                tempContext.globalAlpha = 1;
            }
        });

        // Vẽ hành động hiện tại
        if (currentAction) {
            tempContext.beginPath();
            tempContext.lineCap = 'round';
            tempContext.lineJoin = 'round';
            tempContext.strokeStyle = currentAction.color;
            tempContext.lineWidth = currentAction.size / zoomFactor;

            if (currentAction.brushType === 'paint') {
                tempContext.globalAlpha = 0.5;
                tempContext.lineWidth = (currentAction.size * 2) / zoomFactor;
            } else if (currentAction.brushType === 'marker') {
                tempContext.globalAlpha = 0.7;
            } else if (currentAction.brushType === 'pen') {
                tempContext.lineWidth = (currentAction.size * 0.5) / zoomFactor;
            }

            if ((currentAction.type === 'freehand' || currentAction.type === 'erase') && 
                currentAction.points && currentAction.points.length > 0) {
                tempContext.moveTo(currentAction.points[0].x, currentAction.points[0].y);
                currentAction.points.forEach(point => tempContext.lineTo(point.x, point.y));
                tempContext.strokeStyle = currentAction.type === 'erase' ? '#FFFFFF' : currentAction.color;
                tempContext.globalCompositeOperation = currentAction.type === 'erase' ? 'destination-out' : 'source-over';
                tempContext.stroke();
            } else if (currentAction.type === 'line') {
                if (currentAction.fromX !== undefined && currentAction.fromY !== undefined && 
                    currentAction.toX !== undefined && currentAction.toY !== undefined) {
                    tempContext.moveTo(currentAction.fromX, currentAction.fromY);
                    tempContext.lineTo(currentAction.toX, currentAction.toY);
                    tempContext.stroke();
                }
            } else if (currentAction.type === 'rectangle') {
                if (currentAction.x !== undefined && currentAction.y !== undefined && 
                    currentAction.width !== undefined && currentAction.height !== undefined) {
                    tempContext.strokeRect(currentAction.x, currentAction.y, currentAction.width, currentAction.height);
                }
            } else if (currentAction.type === 'circle') {
                if (currentAction.x !== undefined && currentAction.y !== undefined && 
                    currentAction.radius !== undefined) {
                    tempContext.beginPath();
                    tempContext.arc(currentAction.x, currentAction.y, currentAction.radius, 0, 2 * Math.PI);
                    tempContext.stroke();
                }
            }

            tempContext.globalAlpha = 1;
        }

        // Restore contexts và copy temp canvas to main canvas
        context.restore();
        tempContext.restore();
        context.drawImage(tempCanvas, 0, 0);

    }, [currentPage, currentAction, zoomLevel, zoomFactor, selectedElements]);

    const handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {
        const point = getMousePosition(e);

        if (currentTool === 'select') {
            const clickedElement = currentPage.commands.find(cmd => {
                if (cmd.type === 'freehand' || cmd.type === 'erase') {
                    return cmd.points?.some(p => 
                        Math.abs(p.x - point.x) < 5 && 
                        Math.abs(p.y - point.y) < 5
                    );
                } else if (cmd.type === 'line' && cmd.fromX !== undefined && cmd.fromY !== undefined && 
                    cmd.toX !== undefined && cmd.toY !== undefined) {
                    const dx = cmd.toX - cmd.fromX;
                    const dy = cmd.toY - cmd.fromY;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const dist = Math.abs((dy * point.x - dx * point.y + cmd.toX * cmd.fromY - cmd.toY * cmd.fromX) / length);
                    return dist < 5;
                } else if (cmd.type === 'rectangle' && cmd.x !== undefined && cmd.y !== undefined && 
                    cmd.width !== undefined && cmd.height !== undefined) {
                    return point.x >= cmd.x && point.x <= cmd.x + cmd.width && 
                           point.y >= cmd.y && point.y <= cmd.y + cmd.height;
                } else if (cmd.type === 'circle' && cmd.x !== undefined && cmd.y !== undefined && 
                    cmd.radius !== undefined) {
                    const dx = point.x - cmd.x;
                    const dy = point.y - cmd.y;
                    return Math.sqrt(dx * dx + dy * dy) <= cmd.radius;
                }
                return false;
            });

            if (clickedElement) {
                if (!selectedElements.includes(clickedElement)) {
                    if (!e.shiftKey) {
                        setSelectedElements([clickedElement]);
                    } else {
                        setSelectedElements(prev => [...prev, clickedElement]);
                    }
                }
                setIsDragging(true);
                setDragStart(point);
            } else {
                if (!e.shiftKey) {
                    setSelectedElements([]);
                }
                handleStartSelect(point);
            }
        } else {
            setSelectedElements([]);
            const newAction: DrawingCommand = {
                type: currentTool === 'pencil' ? 'freehand' : currentTool,
                points: ['freehand', 'erase'].includes(currentTool) ? [point] : undefined,
                fromX: currentTool === 'line' ? point.x : undefined,
                fromY: currentTool === 'line' ? point.y : undefined,
                toX: currentTool === 'line' ? point.x : undefined,
                toY: currentTool === 'line' ? point.y : undefined,
                x: ['rectangle', 'circle'].includes(currentTool) ? point.x : undefined,
                y: ['rectangle', 'circle'].includes(currentTool) ? point.y : undefined,
                width: currentTool === 'rectangle' ? 0 : undefined,
                height: currentTool === 'rectangle' ? 0 : undefined,
                radius: currentTool === 'circle' ? 0 : undefined,
                color: currentColor,
                size: currentBrushSize,
                brushType: currentBrushType
            };

            if (currentTool === 'text') {
                setTextPosition(point);
                setShowTextInput(true);
                return;
            }

            setCurrentAction(newAction);
            setIsDrawing(true);
        }
    };

    const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {
        const point = getMousePosition(e);

        if (currentTool === 'select') {
            if (isDragging && dragStart && selectedElements.length > 0) {
                const offsetX = point.x - dragStart.x;
                const offsetY = point.y - dragStart.y;
                updateSelectedElements(offsetX, offsetY);
                setDragStart(point);
            } else if (selectionArea) {
                handleUpdateSelection(point);
            }
        } else if (isDrawing && currentAction) {
            if (currentAction.type === 'freehand' || currentAction.type === 'erase') {
                setCurrentAction(prev => ({
                    ...prev!,
                    points: [...(prev!.points || []), point]
                }));
            } else if (currentAction.type === 'line') {
                setCurrentAction(prev => ({
                    ...prev!,
                    toX: point.x,
                    toY: point.y
                }));
            } else if (currentAction.type === 'rectangle') {
                setCurrentAction(prev => ({
                    ...prev!,
                    x: Math.min(prev!.x!, point.x),
                    y: Math.min(prev!.y!, point.y),
                    width: Math.abs(point.x - prev!.x!),
                    height: Math.abs(point.y - prev!.y!)
                }));
            } else if (currentAction.type === 'circle') {
                const dx = point.x - currentAction.x!;
                const dy = point.y - currentAction.y!;
                const radius = Math.sqrt(dx * dx + dy * dy);
                setCurrentAction(prev => ({ ...prev!, radius }));
            }
        }
    };

    const handleMouseUp = () => {
        if (currentTool === 'select') {
            if (isDragging) {
                setIsDragging(false);
                setDragStart(null);
            } else if (selectionArea) {
                handleFinishSelect();
            }
        } else if (isDrawing && currentAction) {
            setCurrentPage(prev => ({
                ...prev,
                commands: [...prev.commands, currentAction]
            }));
            setCurrentAction(null);
            setIsDrawing(false);
        }
    };

    useEffect(() => {
        if (!canvasRef.current || !tempCanvasRef.current) return;

        const canvas = canvasRef.current;
        const tempCanvas = tempCanvasRef.current;
        
        const resizeCanvas = () => {
            const parent = canvas.parentElement;
            if (!parent) return;

            const dpr = window.devicePixelRatio || 1;
            const rect = parent.getBoundingClientRect();
            
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            tempCanvas.width = rect.width * dpr;
            tempCanvas.height = rect.height * dpr;
            
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;
            tempCanvas.style.width = `${rect.width}px`;
            tempCanvas.style.height = `${rect.height}px`;
        };

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        return () => window.removeEventListener('resize', resizeCanvas);
    }, []);

    return (
        <div className="relative w-full h-[600px]">
            <canvas
                ref={canvasRef}
                className="absolute top-0 left-0 w-full h-full"
                onMouseDown={handleMouseDown}
                onMouseMove={handleMouseMove}
                onMouseUp={handleMouseUp}
                onMouseLeave={handleMouseUp}
                style={{ cursor: currentTool === 'select' ? 'crosshair' : 'default' }}
            />
            <canvas
                ref={tempCanvasRef}
                className="absolute top-0 left-0 w-full h-full pointer-events-none"
            />
            {selectionArea && (
                <div
                    className="absolute border-2 border-blue-500 bg-blue-200 bg-opacity-20 pointer-events-none"
                    style={{
                        left: selectionArea.x * zoomFactor,
                        top: selectionArea.y * zoomFactor,
                        width: selectionArea.width * zoomFactor,
                        height: selectionArea.height * zoomFactor
                    }}
                />
            )}
            {selectedElements.map((element, index) => {
                if (element.type === 'freehand' || element.type === 'line' || 
                    element.type === 'rectangle' || element.type === 'circle') {
                    const bounds = element.type === 'freehand' && element.points 
                        ? {
                            x: Math.min(...element.points.map(p => p.x)),
                            y: Math.min(...element.points.map(p => p.y)),
                            width: Math.max(...element.points.map(p => p.x)) - Math.min(...element.points.map(p => p.x)),
                            height: Math.max(...element.points.map(p => p.y)) - Math.min(...element.points.map(p => p.y))
                        }
                        : element.type === 'line'
                        ? {
                            x: Math.min(element.fromX!, element.toX!),
                            y: Math.min(element.fromY!, element.toY!),
                            width: Math.abs(element.toX! - element.fromX!),
                            height: Math.abs(element.toY! - element.fromY!)
                        }
                        : {
                            x: element.x!,
                            y: element.y!,
                            width: element.width || element.radius! * 2,
                            height: element.height || element.radius! * 2
                        };

                    return (
                        <div
                            key={index}
                            className="absolute border-2 border-blue-500 bg-transparent"
                            style={{
                                left: bounds.x * zoomFactor,
                                top: bounds.y * zoomFactor,
                                width: bounds.width * zoomFactor,
                                height: bounds.height * zoomFactor,
                                cursor: isDragging ? 'grabbing' : 'grab'
                            }}
                        />
                    );
                }
                return null;
            })}
        </div>
    );
});

export default Canvas2;
